<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Observer API | yanxlg@blog</title><meta name="description" content="前言前端项目中经常需要用到异常监控和埋点功能，虽然大部分情况下我们都会直接接入第三方平台，因为第三方平台相对简单、稳定，通过第三方平台提供的API便可以简单实现服务注册及上报；很少我们会自己去开发一个自己的系统，但是，了解如何去开发异常监控和埋点功能还是非常有必要的。本文不针对方案进行详细介绍，如果有兴趣，可以转到前端异常监控和前端埋点实现详细了解。在思考方案过程中，我们想到了，观察者模式中提到浏"><meta name="keywords" content="React、Vue、H5、Nodejs、Deno、Nginx、ReactNative、react-native、react、vue、h5、nodejs、node、Node、Webpack、webpack、weex、Weex、umi、rax、egg"><meta name="author" content="yanxlg"><meta name="copyright" content="yanxlg"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="cg1zWFKfJ7"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Observer API"><meta name="twitter:description" content="前言前端项目中经常需要用到异常监控和埋点功能，虽然大部分情况下我们都会直接接入第三方平台，因为第三方平台相对简单、稳定，通过第三方平台提供的API便可以简单实现服务注册及上报；很少我们会自己去开发一个自己的系统，但是，了解如何去开发异常监控和埋点功能还是非常有必要的。本文不针对方案进行详细介绍，如果有兴趣，可以转到前端异常监控和前端埋点实现详细了解。在思考方案过程中，我们想到了，观察者模式中提到浏"><meta name="twitter:image" content="https://blog.yanxlg.cn/images/bg.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="Observer API"><meta property="og:url" content="https://blog.yanxlg.cn/e4278974/"><meta property="og:site_name" content="yanxlg@blog"><meta property="og:description" content="前言前端项目中经常需要用到异常监控和埋点功能，虽然大部分情况下我们都会直接接入第三方平台，因为第三方平台相对简单、稳定，通过第三方平台提供的API便可以简单实现服务注册及上报；很少我们会自己去开发一个自己的系统，但是，了解如何去开发异常监控和埋点功能还是非常有必要的。本文不针对方案进行详细介绍，如果有兴趣，可以转到前端异常监控和前端埋点实现详细了解。在思考方案过程中，我们想到了，观察者模式中提到浏"><meta property="og:image" content="https://blog.yanxlg.cn/images/bg.jpeg"><meta property="article:published_time" content="2019-01-04T04:02:24.000Z"><meta property="article:modified_time" content="2020-05-12T10:15:46.141Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://blog.yanxlg.cn/e4278974/"><link rel="prev" title="前端异常监控" href="https://blog.yanxlg.cn/ff61036/"><link rel="next" title="require" href="https://blog.yanxlg.cn/41266748/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: {"languages":{"author":"Author: yanxlg","link":"Link: ","source":"Source: yanxlg@blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/custom.css"><script src="/custom.js"><!-- 增加performance--><script src="/js/performance.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="yanxlg@blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/images/avatar.svg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">47</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/react/"><i class="fa-fw blog-icon icon-react"></i><span> React</span></a></li><li><a class="site-page" href="/categories/vue/"><i class="fa-fw blog-icon icon-vue"></i><span> Vue</span></a></li><li><a class="site-page" href="/categories/nodejs/"><i class="fa-fw blog-icon icon-node"></i><span> Nodejs</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#详细介绍"><span class="toc-number">3.</span> <span class="toc-text">详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intersection-Observer：交叉观察者"><span class="toc-number">3.1.</span> <span class="toc-text">Intersection Observer：交叉观察者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#意义："><span class="toc-number">3.1.1.</span> <span class="toc-text">意义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优势："><span class="toc-number">3.1.2.</span> <span class="toc-text">优势：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本使用："><span class="toc-number">3.1.3.</span> <span class="toc-text">基本使用：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutation-Observer：变动观察者"><span class="toc-number">3.2.</span> <span class="toc-text">Mutation Observer：变动观察者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#意义"><span class="toc-number">3.2.1.</span> <span class="toc-text">意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优势"><span class="toc-number">3.2.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本使用"><span class="toc-number">3.2.3.</span> <span class="toc-text">基本使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResizeObserver，视图观察者"><span class="toc-number">3.3.</span> <span class="toc-text">ResizeObserver，视图观察者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#意义：-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">意义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优势-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本使用-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">基本使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PerformanceObserver：性能观察者"><span class="toc-number">3.4.</span> <span class="toc-text">PerformanceObserver：性能观察者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#意义：-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">意义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优势-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用"><span class="toc-number">4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">5.</span> <span class="toc-text">参考文章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#兼容性"><span class="toc-number">6.</span> <span class="toc-text">兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/images/bg.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">yanxlg@blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/react/"><i class="fa-fw blog-icon icon-react"></i><span> React</span></a></li><li><a class="site-page" href="/categories/vue/"><i class="fa-fw blog-icon icon-vue"></i><span> Vue</span></a></li><li><a class="site-page" href="/categories/nodejs/"><i class="fa-fw blog-icon icon-node"></i><span> Nodejs</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Observer API</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2019-01-04 12:02:24"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-01-04</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-05-12 18:15:46"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-05-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/h5/">h5</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/h5/API/">API</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>Word count:</span><span class="word-count">4.5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>Reading time: 17 min</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>Comments:</span><a href="/e4278974/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端项目中经常需要用到异常监控和埋点功能，虽然大部分情况下我们都会直接接入第三方平台，因为第三方平台相对简单、稳定，通过第三方平台提供的API便可以简单实现服务注册及上报；很少我们会自己去开发一个自己的系统，但是，了解如何去开发异常监控和埋点功能还是非常有必要的。本文不针对方案进行详细介绍，如果有兴趣，可以转到<a href="/ff61036/" title="前端异常监控">前端异常监控</a>和<a href="/8e6ad7f6/" title="前端埋点实现">前端埋点实现</a>详细了解。<br>在思考方案过程中，我们想到了，观察者模式中提到浏览器自带的观察者如下：</p>
<div class="note ">
            <p>1、Intersection Observer，交叉观察者。<br>2、Mutation Observer，变动观察者。<br>3、Resize Observer，视图观察者。<br>4、Performance Observer，性能观察者。</p>
          </div>


<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><table>
<thead>
<tr>
<th>&emsp;&emsp;</th>
<th>Intersection Observer</th>
<th>Mutation Observer</th>
<th>Resize Observer</th>
<th>Performance Observer</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>观察一个元素是否在viewport中可视</td>
<td>观察DOM中的变化</td>
<td>观察DOM元素大小的变化</td>
<td>检测性能度量事件</td>
</tr>
<tr>
<td>方法</td>
<td>observe()<br>disconnect()<br>takeRecords()<br>unobserve()</td>
<td>observe()<br>disconnect()<br>takeRecords()<br>unobserve()</td>
<td>observe()<br>disconnect()<br>unobserve()</td>
<td>observe()<br>disconnect()<br>takeRecords()</td>
</tr>
<tr>
<td>替代</td>
<td>DOM Mutation events</td>
<td>getBoundingRect()返回元素大小及其相对于viewport的位置<br>Scroll和Resize事件</td>
<td>Resize事件</td>
<td>Performance接口</td>
</tr>
<tr>
<td>场景</td>
<td>1.无限滚动<br>2.图片懒加载<br>3.兴趣埋点<br>4.<code>控制动画、视频执行</code>（性能优化）</td>
<td>1.更高性能的数据绑定和响应<br>2.实现视觉差滚动<br>3.图片预加载<br>4.富文本编辑器实现</td>
<td>1.更智能的响应式布局（取代@media）<br>2.响应式组件</td>
<td>1.更细颗粒的性能检测<br>2.分析性能对业务的影响</td>
</tr>
</tbody></table>
<h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="Intersection-Observer：交叉观察者"><a href="#Intersection-Observer：交叉观察者" class="headerlink" title="Intersection Observer：交叉观察者"></a>Intersection Observer：交叉观察者</h3><blockquote>
<p><code>IntersectionObserver</code>接口，提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(<code>viewport</code>)交叉状态的方法，祖先元素与视窗(<code>viewport</code>)被称为根(<code>root</code>)</p>
</blockquote>
<h4 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h4><p>想要实时计算Web页面元素的位置，并根据位置进行交互控制，从而实现前端性能优化，这方面的实现非常依赖于<code>DOM</code>状态的显示查询，但这些查询是<code>同步</code>的，会导致昂贵的样式计算开销（重绘和回流），且不停轮询会导致大量的性能浪费。早起针对此问题有以下几种方案：</p>
<ul>
<li>定时器轮询计算每个元素的实时可见性</li>
<li>基于<code>享元模式</code>实现数据绑定的高性能滚动列表，列表中呈现的是数据集的子集</li>
<li>通过onscroll事件实时计算元素的可见性<br>这些方案存在以下共同点：<div class="note ">
            <ol><li>都是查询各个元素相对与某些元素（全局视口）的“被动查询”。</li><li>过度增长的CPU使用，牺牲CPU提升性能。</li></ol>
          </div>

</li>
</ul>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p><code>Intersection Observer API</code>通过为开发人员提供一种新方法来<code>异步</code>查询元素相对于其他元素或全局视口的位置，从而解决了上述问题:</p>
<ul>
<li>异步处理消除了昂贵的DOM和样式查询，连续轮询以及使用自定义scroll插件的需求。</li>
<li>使应用程序显着降低CPU，GPU和资源成本。</li>
</ul>
<h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><ol>
<li><p>创建观察者：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    root: <span class="built_in">document</span>.querySelector(<span class="string">'.scrollContainer'</span>),</span><br><span class="line">    rootMargin: <span class="string">'0px'</span>,</span><br><span class="line">    threshold: [<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1</span>] </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(handler, options)</span><br></pre></td></tr></table></figure>
<p>配置参数的含义：<br><code>root</code>：指定根元素即观察区域元素<br><code>rootMargin</code>：通过类似css margin的值设置观察区域相对于root大小的扩展<br><code>threshold</code>：阈值，<code>number</code>或<code>Array&lt;number&gt;</code>，指定当目标元素在root指定区域内，当可见度等于阈值时触发调度函数</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="/e4278974/640.webp" class="" title="对比图">
</li>
<li><p>定义回调事件<br>当目标与根元素通过阈值相交时，就会触发回调函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IntersectionObserverEntry &#123;</span><br><span class="line">    readonly boundingClientRect: ClientRect | DOMRect;</span><br><span class="line">    readonly intersectionRatio: <span class="built_in">number</span>;</span><br><span class="line">    readonly intersectionRect: ClientRect | DOMRect;</span><br><span class="line">    readonly isIntersecting: <span class="built_in">boolean</span>;</span><br><span class="line">    readonly rootBounds: ClientRect | DOMRect | <span class="literal">null</span>;</span><br><span class="line">    readonly target: Element;</span><br><span class="line">    readonly time: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span> (<span class="params">entries:IntersectionObserverEntry[], observer</span>) </span>&#123; </span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 每个成员都是一个IntersectionObserverEntry对象。</span></span><br><span class="line">    <span class="comment">// 举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</span></span><br><span class="line">    <span class="comment">// entry.boundingClientRect </span></span><br><span class="line">    <span class="comment">// entry.intersectionRatio </span></span><br><span class="line">    <span class="comment">// entry.intersectionRect </span></span><br><span class="line">    <span class="comment">// entry.isIntersecting </span></span><br><span class="line">    <span class="comment">// entry.rootBounds </span></span><br><span class="line">    <span class="comment">// entry.target </span></span><br><span class="line">    <span class="comment">// entry.time </span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time</code>：返回交叉被触发的时间的时间戳，可见性发生变化的时间，是一个高精度时间戳，单位为毫秒<br><code>rootBounds</code>：返回包含根元素的矩形区域的信息<br><code>boundingClientRect</code>：返回包含目标元素的矩形区域的信息，边界的计算方式与 <code>getBoundingClientRect()</code> 相同<br><code>intersectionRect</code>： 返回根元素和目标元素的交叉区域的信息<br><code>intersectionRatio</code>： 返回目标元素的可见比例,也就是 intersectionRect 占 boundingClientRect 的比例值，见下图<br><code>target</code>：返回目标元素的 dom 节点对象<br><code>isIntersecting</code>：目标元素是否与根元素相交</p>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="/e4278974/641.webp" class="" title="对比图">
</li>
<li><p>定义观察目标对象<br>任何目标元素都可以通过调用<code>.observer(target)</code>方法来观察。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.querySelector(<span class="string">".targetBox"</span>); </span><br><span class="line">observer.observe(target);</span><br></pre></td></tr></table></figure>
<p>此外，还有两个停止监听的方法方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observer.unobserve(target);<span class="comment">// 停止对某目标的监听</span></span><br><span class="line">observer.disconnect();<span class="comment">// 终止对所有目标的监听</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例1：图片懒加载</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placeholder.png"</span> <span class="attr">data-src</span>=<span class="string">"img-1.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placeholder.png"</span> <span class="attr">data-src</span>=<span class="string">"img-2.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placeholder.png"</span> <span class="attr">data-src</span>=<span class="string">"img-3.jpg"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- more images --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries, observer</span>)=&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 替换属性 */</span></span><br><span class="line">        entry.target.src = entry.target.dataset.src;</span><br><span class="line">        observer.unobserve(entry.target);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(callback,&#123;rootMargin: <span class="string">"0px 0px -200px 0px"</span>&#125;);</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>).forEach(<span class="function"><span class="params">img</span> =&gt;</span> &#123; observer.observe(img) &#125;);</span><br></pre></td></tr></table></figure>
<p>html中通过js遍历或模板方式输出一批图片元素，其src属性指定为固定的logo或者占位图，并设置其data-src属性为真实图片地址，在js中通过观察器观察，当图片进入窗口区域底部200px位置时开始替换属性加载真实图片并且回收该元素监听。当然由于API兼容性问题，真实的图片懒加载不可能只有这么多代码，如要考虑在API不兼容的情况下，通过scroll事件和节流消抖来轮询检测元素位置，具体参考<a href="/f0e261b6/" title="图片懒加载">图片懒加载</a>。</p>
</li>
<li><p>示例2：兴趣埋点<br>关于兴趣埋点，一个比较通用的方案是：</p>
<blockquote>
<p>来自：《超好用的API之IntersectionObserver》</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> boxList = [...document.querySelectorAll(<span class="string">'.box'</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span>&#123;</span><br><span class="line">  entries.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// intersectionRatio === 1说明该元素完全暴露出来，符合业务需求</span></span><br><span class="line">    <span class="keyword">if</span> (item.intersectionRatio === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO 埋点曝光代码</span></span><br><span class="line">      io.unobserve(item.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  root: <span class="literal">null</span>,</span><br><span class="line">  threshold: <span class="number">1</span>, <span class="comment">// 阀值设为1，当只有比例达到1时才触发回调函数</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// observe遍历监听所有box节点</span></span><br><span class="line">boxList.forEach(<span class="function"><span class="params">box</span> =&gt;</span> io.observe(box));</span><br></pre></td></tr></table></figure>
<p>至于怎样评断用户是否感兴趣，方案就多种多样了，此处不作叙述，需要可以查看<a href="/8e6ad7f6/" title="埋点">埋点</a></p>
</li>
<li><p>示例3：控制动画视频执行<br>这是一个比较常见的场景，如果h5列表元素中包含动画或视频，此优化是必须的，经常在面试中也会问到此类问题，此处介绍视频的控制：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"OSRO-animation.mp4"</span> <span class="attr">controls</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</span><br><span class="line"><span class="keyword">let</span> isPaused = <span class="literal">false</span>; <span class="comment">/* Flag for auto-paused video */</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123; </span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(entry.intersectionRatio!=<span class="number">1</span>  &amp;&amp; !video.paused)&#123;</span><br><span class="line">      video.pause(); isPaused = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isPaused) &#123;video.play(); isPaused=<span class="literal">false</span>&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, &#123;threshold: <span class="number">1</span>&#125;);</span><br><span class="line">observer.observe(video);</span><br></pre></td></tr></table></figure>
<p>这只是简单的实现，当然页面中有多个视频组成视频列表时还需要控制什么情况下才开始播放，播放中的视频仅能有一个，否则出现混乱，影响用户体验。</p>
</li>
</ol>
<hr>

<h3 id="Mutation-Observer：变动观察者"><a href="#Mutation-Observer：变动观察者" class="headerlink" title="Mutation Observer：变动观察者"></a>Mutation Observer：变动观察者</h3><blockquote>
<p>接口提供了监视对DOM树所做更改的能力。它被设计为旧的MutationEvents功能的替代品，该功能是DOM3 Events规范的一部分。</p>
</blockquote>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>归根究底，是MutationEvents的功能不尽人意：</p>
<div class="note ">
            <ol><li>在<code>MDN</code>中也写到了，是由于<code>DOM Event</code>承认在API上有缺陷，反对使用。</li><li>核心缺陷是：性能问题和跨浏览器支持。</li><li>为DOM添加 <code>mutation</code> 监听器极度降低进一步修改DOM文档的性能（慢1.5 - 7倍），此外, 移除监听器不会逆转的损害。</li></ol>
          </div>
<p>MutationEvents的原理：通过绑定事件监听DOM，支持的事件大致如下，不同浏览器存在兼容性差异，不需要去记录他们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DOMAttributeNameChanged</span><br><span class="line">DOMCharacterDataModified</span><br><span class="line">DOMElementNameChanged</span><br><span class="line">DOMNodeInserted</span><br><span class="line">DOMNodeInsertedIntoDocument</span><br><span class="line">DOMNodeRemoved</span><br><span class="line">DOMNodeRemovedFromDocument</span><br><span class="line">DOMSubtreeModified</span><br></pre></td></tr></table></figure>

<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>MutationEvents事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；</li>
<li>Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</li>
<li>可以通过配置项，监听目标DOM下子元素的变更记录</li>
</ol>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li><p>创建观察者</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(callback);</span><br></pre></td></tr></table></figure></li>
<li><p>定义回调函数<br>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MutationRecord &#123;</span><br><span class="line">    readonly addedNodes: NodeList;</span><br><span class="line">    readonly attributeName: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">    readonly attributeNamespace: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">    readonly nextSibling: Node | <span class="literal">null</span>;</span><br><span class="line">    readonly oldValue: <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line">    readonly previousSibling: Node | <span class="literal">null</span>;</span><br><span class="line">    readonly removedNodes: NodeList;</span><br><span class="line">    readonly target: Node;</span><br><span class="line">    readonly <span class="keyword">type</span>: MutationRecordType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">mutations:MutationRecord[], observer</span>) </span>&#123;</span><br><span class="line">  mutations.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MutationRecord</code>对象中各属性含义如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>观察的变动类型（<code>attribute</code>、<code>characterData</code>或者<code>childList</code>）</td>
</tr>
<tr>
<td>target</td>
<td>发生变动的<code>DOM</code>节点</td>
</tr>
<tr>
<td>addedNodes</td>
<td>新增的<code>DOM</code>节点</td>
</tr>
<tr>
<td>removedNodes</td>
<td>删除的<code>DOM</code>节点</td>
</tr>
<tr>
<td>previousSibling</td>
<td>前一个同级节点，如果没有则返回null</td>
</tr>
<tr>
<td>nextSibling</td>
<td>下一个同级节点，如果没有则返回null</td>
</tr>
<tr>
<td>attributeName</td>
<td>发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性</td>
</tr>
<tr>
<td>oldValue</td>
<td>变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回null</td>
</tr>
</tbody></table>
</li>
<li><p>定义要观察的目标</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MutationObserverInit &#123;</span><br><span class="line">    attributeFilter?: <span class="built_in">string</span>[];</span><br><span class="line">    attributeOldValue?: <span class="built_in">boolean</span>;</span><br><span class="line">    attributes?: <span class="built_in">boolean</span>;</span><br><span class="line">    characterData?: <span class="built_in">boolean</span>;</span><br><span class="line">    characterDataOldValue?: <span class="built_in">boolean</span>;</span><br><span class="line">    childList?: <span class="built_in">boolean</span>;</span><br><span class="line">    subtree?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutationObserver.observe(content, &#123;</span><br><span class="line">    attributes: <span class="literal">true</span>, <span class="comment">// Boolean - 观察目标属性的改变</span></span><br><span class="line">    characterData: <span class="literal">true</span>, <span class="comment">// Boolean - 观察目标数据的改变(改变前的数据/值)</span></span><br><span class="line">    childList: <span class="literal">true</span>, <span class="comment">// Boolean - 观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</span></span><br><span class="line">    subtree: <span class="literal">true</span>, <span class="comment">// Boolean - 目标以及目标的后代改变都会观察</span></span><br><span class="line">    attributeOldValue: <span class="literal">true</span>, <span class="comment">// Boolean - 表示需要记录改变前的目标属性值</span></span><br><span class="line">    characterDataOldValue: <span class="literal">true</span>, <span class="comment">// Boolean - 设置了characterDataOldValue可以省略characterData设置</span></span><br><span class="line">    <span class="comment">// attributeFilter: ['src', 'class'] // Array - 观察指定属性</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>优先级如下：</p>
<div class="note ">
            <p>1、attributeFilter/attributeOldValue &gt; attributes<br>2、characterDataOldValue &gt; characterData<br>3、attributes/characterData/childList（或更高级特定项）至少有一项为true；<br>4、特定项存在, 对应选项可以忽略或必须为true</p>
          </div>
<p>此外，还有两个停止观察的方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutationObserver.unobserve(target);<span class="comment">// 取消观察某个元素</span></span><br><span class="line">mutationObserver.disconnect();<span class="comment">// 全部取消观察</span></span><br><span class="line">mutationObserver.takeRecords();<span class="comment">// 清除变动记录。即不再处理未处理的变动。该方法返回变动记录的数组，注意，该方法立即生效。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例子1：监听文本变化</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">'target-id'</span>);</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">records</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 输入变更记录</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">observer.observe(target, &#123;</span><br><span class="line">  characterData: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里可以有几种处理。</p>
<ol>
<li>聊天的气泡框彩蛋，检测文本中的指定字符串/表情包，触发类似微信聊天的表情落下动画。</li>
<li>输入框的热点话题搜索，当输入”#”号时，启动搜索框预检文本或高亮话题。</li>
</ol>
<p>有个<code>Vue</code>的小型插件就是这么实现的：</p>
<blockquote>
<p>来自：《vue-hashtag-textarea》</p>
</blockquote>
</li>
</ol>
<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="/e4278974/642.gif" class="">


<h3 id="ResizeObserver，视图观察者"><a href="#ResizeObserver，视图观察者" class="headerlink" title="ResizeObserver，视图观察者"></a>ResizeObserver，视图观察者</h3><p><code>ResizeObserver API</code>是一个新的JavaScript API，与<code>IntersectionObserver API</code>非常相似，它们都允许我们去监听某个元素的变化。</p>
<h4 id="意义：-1"><a href="#意义：-1" class="headerlink" title="意义："></a>意义：</h4><ul>
<li>开发过程当中经常遇到的一个问题就是如何监听一个 div 的尺寸变化。</li>
<li>但众所周知，为了监听 div 的尺寸变化，都将侦听器附加到 window 中的 resize 事件。</li>
<li>但这很容易导致性能问题，因为大量的触发事件。</li>
<li>换句话说，使用<code>window.resize</code> 通常是浪费的，因为它告诉我们每个视窗大小的变化，而不仅仅是当一个元素的大小发生变化。</li>
<li>而且<code>resize</code>事件会在一秒内触发将近60次，很容易在改变窗口大小时导致性能问题，比如说，你要调整一个元素的大小，那就需要在 <code>resize</code> 的回调函数 callback() 中调用 <code>getBoundingClientRect</code> 或 <code>getComputerStyle</code>。不过你要是不小心处理所有的读和写操作，就会导致布局混乱。</li>
</ul>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul>
<li>细颗粒度的<code>DOM元素</code>观察，而不是window，当然是用<code>resize</code>也可以实现单个元素的监听，具体方案参考</li>
<li>没有额外的性能开销，只会在绘制前或布局后触发调用</li>
</ul>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li><p>创建观察者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> ResizeObserver(callback);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义回调函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> ResizeObserverEntry &#123;</span><br><span class="line">      readonly contentRect: DOMRectReadOnly;</span><br><span class="line">      readonly target: Element;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries:ResizeObserverEntry[]</span>) =&gt;</span> &#123;</span><br><span class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义要观察的目标</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.observe(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure>
<p>此外，取消观察的api有：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observer.unobserve(<span class="built_in">document</span>.body);<span class="comment">// 取消特定元素</span></span><br><span class="line">observer.disconnect();<span class="comment">// 全部取消</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例子1：响应式组件<br>前端响应式组件通常是使用<code>@media</code>去实现的，但是<code>@media</code>仅能监控窗口大小，不能监控元素本身大小，如果布局发生改变，<code>@media</code>的响应式会存在一些问题，完美的响应式组件是监控元素本身大小，例如<code>vue-responsive-components</code>库的实现，就是通过ResizeObserver观察元素本身大小变化从而实现响应式。</p>
</li>
</ol>
<h3 id="PerformanceObserver：性能观察者"><a href="#PerformanceObserver：性能观察者" class="headerlink" title="PerformanceObserver：性能观察者"></a><code>PerformanceObserver</code>：性能观察者</h3><p>这是一个浏览器和Node.js 里都存在的API，采用相同W3C的Performance Timeline规范</p>
<ul>
<li>在浏览器中，我们可以使用 window 对象取得window.performance和 window.PerformanceObserver 。</li>
<li>而在 Node.js 程序中需要perf_hooks 取得性能对象，如下：<code>const { PerformanceObserver, performance } = require(&#39;perf_hooks&#39;);</code></li>
</ul>
<h4 id="意义：-2"><a href="#意义：-2" class="headerlink" title="意义："></a>意义：</h4><ul>
<li>可以获取到当前页面中与性能相关的信息。它是 <code>High Resolution Time API</code> 的一部分，同时也融合了 <code>Performance Timeline API</code>、<code>Navigation Timing API</code>、 <code>User Timing API</code> 和 <code>Resource Timing API</code></li>
<li><code>Performance API</code> 是大家熟悉的一个接口，他记录着几种性能指数的庞大对象集合<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PerformanceTiming &#123;</span><br><span class="line">    readonly connectEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly connectStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly domComplete: <span class="built_in">number</span>;</span><br><span class="line">    readonly domContentLoadedEventEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly domContentLoadedEventStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly domInteractive: <span class="built_in">number</span>;</span><br><span class="line">    readonly domLoading: <span class="built_in">number</span>;</span><br><span class="line">    readonly domainLookupEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly domainLookupStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly fetchStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly loadEventEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly loadEventStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly navigationStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly redirectEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly redirectStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly requestStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly responseEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly responseStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly secureConnectionStart: <span class="built_in">number</span>;</span><br><span class="line">    readonly unloadEventEnd: <span class="built_in">number</span>;</span><br><span class="line">    readonly unloadEventStart: <span class="built_in">number</span>;</span><br><span class="line">    toJSON(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Performance <span class="keyword">extends</span> EventTarget &#123;</span><br><span class="line">    <span class="comment">/** @deprecated */</span></span><br><span class="line">    readonly navigation: PerformanceNavigation;</span><br><span class="line">    onresourcetimingbufferfull: <span class="function">(<span class="params">(<span class="params"><span class="keyword">this</span>: Performance, ev: Event</span>) =&gt; <span class="built_in">any</span></span>) | <span class="params">null</span>;</span><br><span class="line">    <span class="params">readonly</span> <span class="params">timeOrigin</span>: <span class="params">number</span>;</span><br><span class="line">    /** @<span class="params">deprecated</span> */</span><br><span class="line">    <span class="params">readonly</span> <span class="params">timing</span>: <span class="params">PerformanceTiming</span>;</span><br><span class="line">    <span class="params">clearMarks</span>(<span class="params">markName?: <span class="built_in">string</span></span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">clearMeasures</span>(<span class="params">measureName?: <span class="built_in">string</span></span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">clearResourceTimings</span><span class="params">()</span>: <span class="params">void</span>;</span><br><span class="line">    <span class="params">getEntries</span><span class="params">()</span>: <span class="params">PerformanceEntryList</span>;</span><br><span class="line">    <span class="params">getEntriesByName</span>(<span class="params">name: <span class="built_in">string</span>, <span class="keyword">type</span>?: <span class="built_in">string</span></span>): <span class="params">PerformanceEntryList</span>;</span><br><span class="line">    <span class="params">getEntriesByType</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span></span>): <span class="params">PerformanceEntryList</span>;</span><br><span class="line">    <span class="params">mark</span>(<span class="params">markName: <span class="built_in">string</span></span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">measure</span>(<span class="params">measureName: <span class="built_in">string</span>, startMark?: <span class="built_in">string</span>, endMark?: <span class="built_in">string</span></span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">now</span><span class="params">()</span>: <span class="params">number</span>;</span><br><span class="line">    <span class="params">setResourceTimingBufferSize</span>(<span class="params">maxSize: <span class="built_in">number</span></span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">toJSON</span><span class="params">()</span>: <span class="params">any</span>;</span><br><span class="line">    <span class="params">addEventListener</span>&lt;<span class="params">K</span> <span class="params">extends</span> <span class="params">keyof</span> <span class="params">PerformanceEventMap</span>&gt;(<span class="params"><span class="keyword">type</span>: K, listener: (<span class="params"><span class="keyword">this</span>: Performance, ev: PerformanceEventMap[K]</span>) =&gt; <span class="built_in">any</span>, options?: <span class="built_in">boolean</span> | AddEventListenerOptions</span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">addEventListener</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span>, listener: EventListenerOrEventListenerObject, options?: <span class="built_in">boolean</span> | AddEventListenerOptions</span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">removeEventListener</span>&lt;<span class="params">K</span> <span class="params">extends</span> <span class="params">keyof</span> <span class="params">PerformanceEventMap</span>&gt;(<span class="params"><span class="keyword">type</span>: K, listener: (<span class="params"><span class="keyword">this</span>: Performance, ev: PerformanceEventMap[K]</span>) =&gt; <span class="built_in">any</span>, options?: <span class="built_in">boolean</span> | EventListenerOptions</span>): <span class="params">void</span>;</span><br><span class="line">    <span class="params">removeEventListener</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span>, listener: EventListenerOrEventListenerObject, options?: <span class="built_in">boolean</span> | EventListenerOptions</span>): <span class="params">void</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><code>Performance API</code>若想获得某项页面加载性能记录，就需要调用performance.getEntries或者performance.getEntriesByName来获得。</li>
<li><code>Performance API</code>而获得执行效率，也只能通过performance.now来计算。</li>
</ul>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><p><code>PerformanceObserver</code>是浏览器内部对<code>Performance</code>实现的观察者模式，也是现代浏览器支持的几个 Observer 之一。</p>
<blockquote>
<p>来自：《你了解 Performance Timeline Level 2 吗？》</p>
</blockquote>
<p>它解决了以下3点问题：</p>
<div class="note ">
            <ol><li>避免不知道性能事件啥时候会发生，需要重复轮训timeline获取记录。</li><li>避免产生重复的逻辑去获取不同的性能数据指标</li><li>避免其他资源需要操作浏览器性能缓冲区时产生竞态关系。</li></ol>
          </div>
<div class="note warning">
            <p><code>W3C</code>官网文档鼓励开发人员尽可能使用<code>PerformanceObserver</code>，而不是通过<code>Performance</code>获取性能参数及指标。</p>
          </div>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>创建观察者</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> PerformanceObserver(callback);</span><br></pre></td></tr></table></figure></li>
<li><p>定义回调函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PerformanceObserverEntryList &#123;</span><br><span class="line">    getEntries(): PerformanceEntryList;</span><br><span class="line">    getEntriesByName(name: <span class="built_in">string</span>, <span class="keyword">type</span>?: <span class="built_in">string</span>): PerformanceEntryList;</span><br><span class="line">    getEntriesByType(<span class="keyword">type</span>: <span class="built_in">string</span>): PerformanceEntryList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> PerformanceEntry &#123;</span><br><span class="line">    readonly duration: <span class="built_in">number</span>;</span><br><span class="line">    readonly entryType: <span class="built_in">string</span>;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    readonly startTime: <span class="built_in">number</span>;</span><br><span class="line">    toJSON(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">list:PerformanceObserverEntryList, observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entries = list.getEntries();</span><br><span class="line">    entries.forEach(<span class="function">(<span class="params">entry:PerformanceEntry</span>) =&gt;</span> &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义要观察的目标对象</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PerformanceObserverInit &#123;</span><br><span class="line">    buffered?: <span class="built_in">boolean</span>;</span><br><span class="line">    entryTypes?: <span class="built_in">string</span>[];</span><br><span class="line">    <span class="keyword">type</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line">observer.observe(&#123;entryTypes: [<span class="string">"entryTypes"</span>]&#125; <span class="keyword">as</span> PerformanceObserverInit);</span><br></pre></td></tr></table></figure>
<p><code>observer.observe(...)</code>方法接受可以观察到的有效的入口类型。这些输入类型可能属于各种性能API，比如<code>User Tming</code>或<code>Navigation Timing API</code>。有效的<code>entryType</code>值：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>别名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>frame<br>navigation</td>
<td><code>PerformanceFrameTiming</code><br><code>PerformanceNavigationTiming</code></td>
<td>URL</td>
<td>文件的地址</td>
</tr>
<tr>
<td>resource</td>
<td><code>PerformanceResourceTiming</code></td>
<td>URL</td>
<td>所请求资源的解析URL</td>
</tr>
<tr>
<td>mark</td>
<td><code>PerformanceMark</code></td>
<td>DOMString</td>
<td>通过调用创建标记时使用的名称performance.mark()</td>
</tr>
<tr>
<td>measure</td>
<td><code>PerformanceMeasure</code></td>
<td>DOMString</td>
<td>通过调用创建度量时使用的名称performance.measure()</td>
</tr>
<tr>
<td>paint</td>
<td><code>PerformancePaintTiming</code></td>
<td>DOMString</td>
<td>无论是<code>first-paint</code>或<code>first-contentful-paint</code></td>
</tr>
<tr>
<td>longtask</td>
<td><code>PerformanceLongTaskTiming</code></td>
<td>DOMString</td>
<td>报告长任务的实例</td>
</tr>
</tbody></table>
</li>
<li><p>例子：静态资源监控</p>
<blockquote>
<p>来自：《资源监控》</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterTime</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; (a - b) &gt;= <span class="number">0</span>) ? (a - b) : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resolvePerformanceTiming = <span class="function">(<span class="params">timing</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;</span><br><span class="line">    initiatorType: timing.initiatorType,</span><br><span class="line">    name: timing.name,</span><br><span class="line">    duration: <span class="built_in">parseInt</span>(timing.duration),</span><br><span class="line">    redirect: filterTime(timing.redirectEnd, timing.redirectStart), <span class="comment">// 重定向</span></span><br><span class="line">    dns: filterTime(timing.domainLookupEnd, timing.domainLookupStart), <span class="comment">// DNS解析</span></span><br><span class="line">    connect: filterTime(timing.connectEnd, timing.connectStart), <span class="comment">// TCP建连</span></span><br><span class="line">    network: filterTime(timing.connectEnd, timing.startTime), <span class="comment">// 网络总耗时</span></span><br><span class="line"></span><br><span class="line">    send: filterTime(timing.responseStart, timing.requestStart), <span class="comment">// 发送开始到接受第一个返回</span></span><br><span class="line">    receive: filterTime(timing.responseEnd, timing.responseStart), <span class="comment">// 接收总时间</span></span><br><span class="line">    request: filterTime(timing.responseEnd, timing.requestStart), <span class="comment">// 总时间</span></span><br><span class="line"></span><br><span class="line">    ttfb: filterTime(timing.responseStart, timing.requestStart), <span class="comment">// 首字节时间</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resolveEntries = <span class="function">(<span class="params">entries</span>) =&gt;</span> entries.map(<span class="function"><span class="params">item</span> =&gt;</span> resolvePerformanceTiming(item));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resources = &#123;</span><br><span class="line">  init: <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> performance = <span class="built_in">window</span>.performance || <span class="built_in">window</span>.mozPerformance || <span class="built_in">window</span>.msPerformance || <span class="built_in">window</span>.webkitPerformance;</span><br><span class="line">    <span class="keyword">if</span> (!performance || !performance.getEntries) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.PerformanceObserver) &#123;</span><br><span class="line">      <span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="built_in">window</span>.PerformanceObserver(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> entries = list.getEntries();</span><br><span class="line">          cb(resolveEntries(entries));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      observer.observe(&#123;</span><br><span class="line">        entryTypes: [<span class="string">'resource'</span>]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> entries = performance.getEntriesByType(<span class="string">'resource'</span>);</span><br><span class="line">        cb(resolveEntries(entries));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<ul>
<li>资源监控</li>
<li>Media Queries Based on Element Width with MutationObserver</li>
<li>以用户为中心的性能指标</li>
<li>A Few Functional Uses for Intersection Observer to Know When an Element is in View</li>
<li>Getting To Know The MutationObserver API</li>
<li>Different Types Of Observers Supported By Modern Browsers</li>
<li>THE RESIZE OBSERVER EXPLAINED</li>
<li>A Look at the Resize Observer JavaScript API </li>
</ul>
</blockquote>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><a href="https://caniuse.com/#search=Intersection%20Observer" target="_blank" rel="noopener">Intersection Observer</a> | <a href="https://caniuse.com/#search=Mutation%20Observer" target="_blank" rel="noopener">Mutation Observer</a> | <a href="https://caniuse.com/#search=Resize%20Observer" target="_blank" rel="noopener">Resize Observer</a> | <a href="https://caniuse.com/#search=Performance%20Observer" target="_blank" rel="noopener">Performance Observer</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这四个观察者，都非常适合集成到监控系统。虽然其兼容性有一定的限制，但是都有对应的polyfills：<br>Intersection Observer：intersection-observer<br>Mutation Observer：mutationobserver-shim<br>Resize Observer：resize-observer-polyfill<br>Performance Observer：@fastly/performance-observer-polyfill</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">yanxlg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://blog.yanxlg.cn/e4278974/">https://blog.yanxlg.cn/e4278974/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/bg.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/images/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/images/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/ff61036/"><img class="prev_cover" data-src="/images/bg.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">前端异常监控</div></div></a></div><div class="next-post pull_right"><a href="/41266748/"><img class="next_cover" data-src="/images/bg.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">require</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '12a1217ff53b08c6c73a',
  clientSecret: '7ee99a0195d3d7837a04a7eeb423f98c960d9f60',
  repo: 'yanxlg.github.io',
  owner: 'yanxlg',
  admin: ['yanxlg'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By yanxlg</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="150" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>